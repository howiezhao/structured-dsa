<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Structured DSA</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> 简介</a></li><li class="chapter-item expanded "><a href="prepare/index.html"><strong aria-hidden="true">2.</strong> 先修</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="prepare/math.html"><strong aria-hidden="true">2.1.</strong> 数学</a></li><li class="chapter-item expanded "><a href="prepare/programming-language.html"><strong aria-hidden="true">2.2.</strong> 编程语言</a></li><li class="chapter-item expanded "><a href="prepare/analysis-of-algorithms.html"><strong aria-hidden="true">2.3.</strong> 算法分析</a></li><li class="chapter-item expanded "><a href="prepare/back-of-the-envelope-calculation.html"><strong aria-hidden="true">2.4.</strong> 封底估算</a></li></ol></li><li class="chapter-item expanded "><a href="linear-list/index.html"><strong aria-hidden="true">3.</strong> 线性表</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="linear-list/contiguous-list.html"><strong aria-hidden="true">3.1.</strong> 顺序表</a></li><li class="chapter-item expanded "><a href="linear-list/linked-list.html"><strong aria-hidden="true">3.2.</strong> 链表</a></li><li class="chapter-item expanded "><a href="linear-list/stack.html"><strong aria-hidden="true">3.3.</strong> 栈</a></li><li class="chapter-item expanded "><a href="linear-list/queue.html"><strong aria-hidden="true">3.4.</strong> 队列</a></li></ol></li><li class="chapter-item expanded "><a href="tree/index.html"><strong aria-hidden="true">4.</strong> 树</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tree/binary-tree/index.html"><strong aria-hidden="true">4.1.</strong> 二叉树</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tree/binary-tree/bst/index.html"><strong aria-hidden="true">4.1.1.</strong> 二叉搜索树</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tree/binary-tree/bst/bbst/index.html"><strong aria-hidden="true">4.1.1.1.</strong> 平衡二叉搜索树</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tree/binary-tree/bst/bbst/avl-tree.html"><strong aria-hidden="true">4.1.1.1.1.</strong> AVL 树</a></li><li class="chapter-item expanded "><a href="tree/binary-tree/bst/bbst/splay-tree.html"><strong aria-hidden="true">4.1.1.1.2.</strong> 伸展树</a></li><li class="chapter-item expanded "><a href="tree/binary-tree/bst/bbst/red-black-tree.html"><strong aria-hidden="true">4.1.1.1.3.</strong> 红黑树</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="tree/b-tree.html"><strong aria-hidden="true">4.2.</strong> B 树</a></li><li class="chapter-item expanded "><a href="tree/b-plus-tree.html"><strong aria-hidden="true">4.3.</strong> B+ 树</a></li></ol></li><li class="chapter-item expanded "><a href="graph/index.html"><strong aria-hidden="true">5.</strong> 图</a></li><li class="chapter-item expanded "><a href="hash-table.html"><strong aria-hidden="true">6.</strong> 哈希表</a></li><li class="chapter-item expanded "><a href="sort/index.html"><strong aria-hidden="true">7.</strong> 排序</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sort/mergesort.html"><strong aria-hidden="true">7.1.</strong> 归并排序</a></li><li class="chapter-item expanded "><a href="sort/quicksort.html"><strong aria-hidden="true">7.2.</strong> 快速排序</a></li><li class="chapter-item expanded "><a href="sort/heapsort.html"><strong aria-hidden="true">7.3.</strong> 堆排序</a></li><li class="chapter-item expanded "><a href="sort/insertionsort.html"><strong aria-hidden="true">7.4.</strong> 插入排序</a></li><li class="chapter-item expanded "><a href="sort/bubblesort.html"><strong aria-hidden="true">7.5.</strong> 冒泡排序</a></li><li class="chapter-item expanded "><a href="sort/selectionsort.html"><strong aria-hidden="true">7.6.</strong> 选择排序</a></li><li class="chapter-item expanded "><a href="sort/countingsort.html"><strong aria-hidden="true">7.7.</strong> 计数排序</a></li><li class="chapter-item expanded "><a href="sort/bucketsort.html"><strong aria-hidden="true">7.8.</strong> 桶排序</a></li><li class="chapter-item expanded "><a href="sort/shellsort.html"><strong aria-hidden="true">7.9.</strong> 希尔排序</a></li></ol></li><li class="chapter-item expanded "><a href="search/index.html"><strong aria-hidden="true">8.</strong> 查找</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="search/binary-search.html"><strong aria-hidden="true">8.1.</strong> 二分查找</a></li><li class="chapter-item expanded "><a href="search/fibonacci-search.html"><strong aria-hidden="true">8.2.</strong> Fibonacci 查找</a></li><li class="chapter-item expanded "><a href="search/interpolation-search.html"><strong aria-hidden="true">8.3.</strong> 插值查找</a></li></ol></li><li class="chapter-item expanded "><a href="string-match/index.html"><strong aria-hidden="true">9.</strong> 字符串匹配</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="string-match/bf.html"><strong aria-hidden="true">9.1.</strong> 暴力匹配</a></li><li class="chapter-item expanded "><a href="string-match/kmp.html"><strong aria-hidden="true">9.2.</strong> KMP</a></li><li class="chapter-item expanded "><a href="string-match/bm.html"><strong aria-hidden="true">9.3.</strong> BM</a></li><li class="chapter-item expanded "><a href="string-match/rabin-karp.html"><strong aria-hidden="true">9.4.</strong> Rabin-Karp</a></li></ol></li><li class="chapter-item expanded "><a href="strategy/index.html"><strong aria-hidden="true">10.</strong> 策略</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="strategy/greedy.html"><strong aria-hidden="true">10.1.</strong> 贪心</a></li><li class="chapter-item expanded "><a href="strategy/reduce-and-conquer.html"><strong aria-hidden="true">10.2.</strong> 减治</a></li><li class="chapter-item expanded "><a href="strategy/divide-and-conquer.html"><strong aria-hidden="true">10.3.</strong> 分治</a></li><li class="chapter-item expanded "><a href="strategy/dynamic-programming.html"><strong aria-hidden="true">10.4.</strong> 动态规划</a></li><li class="chapter-item expanded "><a href="strategy/sliding-window.html"><strong aria-hidden="true">10.5.</strong> 滑动窗口</a></li></ol></li><li class="chapter-item expanded "><a href="common-algo/index.html"><strong aria-hidden="true">11.</strong> 常用算法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="common-algo/lru.html"><strong aria-hidden="true">11.1.</strong> LRU</a></li><li class="chapter-item expanded "><a href="common-algo/union-find.html"><strong aria-hidden="true">11.2.</strong> 并查集</a></li></ol></li><li class="chapter-item expanded "><a href="faq/index.html"><strong aria-hidden="true">12.</strong> 常考题型</a></li><li class="chapter-item expanded "><a href="problem-solving-summary.html"><strong aria-hidden="true">13.</strong> 刷题总结</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Structured DSA</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/howiezhao/structured-dsa" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#简介" id="简介">简介</a></h1>
<p>数据结构即数据的存储结构，不同的存储结构存在不同的优劣，数据结构与算法一般而言是密不可分的，因为实现相应的存储结构之后难免会提供相应的算法，几乎每一种存储结构都会提供一些基本的操作，即“增删改查”。</p>
<p>根据是否修改数据结构，所有操作大致分为两类方式：</p>
<ul>
<li>静态：仅读取，数据结构的内容及组成一般不变：查找</li>
<li>动态：需写入，数据结构的局部或整体将改变：增加、删除</li>
</ul>
<p>数据结构通常可分为：</p>
<ul>
<li><strong>线性数据结构</strong>：线性表、栈、队列</li>
<li><strong>非线性数据结构</strong>：树、图</li>
</ul>
<p>特别的，线性表又具体分为顺序表和链表，而树也可以理解为半线性数据结构。</p>
<p>也可以按照数据访问方式分为：</p>
<ul>
<li>寻秩访问（call by rank）：顺序表</li>
<li>寻位置访问（call by position）：链表</li>
<li>寻关键码访问（call by key）：二叉搜索树</li>
<li>寻优先级访问（call by priority）：优先级队列</li>
<li>寻数值访问（call by value）：哈希</li>
</ul>
<p>常见数据结构的相关操作的时间复杂度：</p>
<table><thead><tr><th>数据结构</th><th>顺序表</th><th>链表</th><th>二叉树</th><th>二叉搜索树</th><th>图</th><th>哈希表</th></tr></thead><tbody>
<tr><td>增加</td><td>\(O(n)\)</td><td>\(O(1)\)</td><td>\(O(logn)\)</td><td>\(O(logn)\)</td><td>\(O(n)\)</td><td>\(O(n)\)</td></tr>
<tr><td>删除</td><td>\(O(n)\)</td><td>\(O(1)\)</td><td>\(O(logn)\)</td><td>\(O(logn)\)</td><td>\(O(n)\)</td><td>\(O(n)\)</td></tr>
<tr><td>修改</td><td>\(O(1)\)</td><td>\(O(n)\)</td><td>\(O(logn)\)</td><td>\(O(logn)\)</td><td>\(O(n)\)</td><td>\(\approx O(1)\)</td></tr>
</tbody></table>
<h1><a class="header" href="#先修" id="先修">先修</a></h1>
<h1><a class="header" href="#数学" id="数学">数学</a></h1>
<h2><a class="header" href="#最大公约数" id="最大公约数">最大公约数</a></h2>
<p><strong>最大公约数</strong>（greatest common divisor，gcd），又称最大公因数（highest common factor，hcf），指能够整除多个整数的最大正整数。而多个整数不能都为零。</p>
<p>例如 8 和 12 的最大公约数为 4。</p>
<h2><a class="header" href="#素数" id="素数">素数</a></h2>
<p><strong>素数</strong>（Prime number），又称质数，指在大于 1 的自然数中，除了 1 和该数自身外，无法被其他自然数整除的数（也可定义为只有 1 与该数本身两个正因数的数）。</p>
<p>如 3、5、7、11、13、17、19、23 等。</p>
<p>更具体来说，素数又可分为两类：</p>
<ul>
<li>4k + 3：3、7、11、19、23 等</li>
<li>非 4k + 3：5、13、17 等</li>
</ul>
<h2><a class="header" href="#斐波那契数列" id="斐波那契数列">斐波那契数列</a></h2>
<h2><a class="header" href="#阶乘" id="阶乘">阶乘</a></h2>
<p>正整数的<strong>阶乘</strong>（factorial）是所有小于及等于该数的正整数的积，计为 \(n!\)。例如：</p>
<p>\(5!=5\times 4\times 3\times 3\times 2\times 1=120\)</p>
<p>特别的，\(1\) 的阶乘 \(1!\) 为 \(1\)、\(0\) 的阶乘 \(0!\) 亦为 \(1\)，其中，\(0\) 的阶乘表示一个空积。</p>
<h2><a class="header" href="#排列组合" id="排列组合">排列组合</a></h2>
<p>从 \(n\) 个元素中取出 \(k\) 个元素，\(k\) 个元素的<strong>排列</strong>数量为：</p>
<p>\(P_k^n=\frac{n!}{(n-k)!}\)</p>
<p>从 \(n\) 个元素中取出 \(k\) 个元素，\(k\) 个元素的<strong>组合</strong>数量为：</p>
<p>\(C_k^n=\frac{n!}{k!(n-k)!}\)</p>
<h2><a class="header" href="#级数与时间复杂度" id="级数与时间复杂度">级数与时间复杂度</a></h2>
<ul>
<li><strong>算数级数</strong>：与<strong>末项平方</strong>同阶</li>
<li><strong>幂方级数</strong>：比幂次高出<strong>一阶</strong></li>
<li><strong>几何级数</strong>（a&gt;1）：与末项同阶</li>
<li><strong>收敛级数</strong>：\(O(1)\)</li>
<li><strong>调和级数</strong>：\(\Theta(logn)\)</li>
<li><strong>对数级数</strong>：\(\Theta(nlogn)\)</li>
</ul>
<pre><code class="language-c">// 算数级数，O(n^2)
for(int i = 0; i &lt; n; i++)
{
    for(int j = 0; j &lt; n; j++)
    {
        O1Operation(i, j);
    }
}
</code></pre>
<pre><code class="language-c">// 算数级数，O(n^2)
for(int i = 0; i &lt; n; i++)
{
    for(int j = 0; j &lt; i; j++)
    {
        O1Operation(i, j);
    }
}
</code></pre>
<pre><code class="language-c">// 算数级数，O(n^2)
for(int i = 0; i &lt; n; i++)
{
    for(int j = 0; j &lt; i; j += 2013)
    {
        O1Operation(i, j);
    }
}
</code></pre>
<pre><code class="language-c">// 几何级数，O(n)
for(int i = 1; i &lt; n; i &lt;&lt;= 1)
{
    for(int j = 0; j &lt; i; j++)
    {
        O1Operation(i, j);
    }
}
</code></pre>
<pre><code class="language-c">// 几何级数，O(logn*2^logn)
for(int i = 0; i &lt;= n; i++)
{
    for(int j = 1; j &lt; i; j += j)
    {
        O1Operation(i, j);
    }
}
</code></pre>
<h1><a class="header" href="#编程语言" id="编程语言">编程语言</a></h1>
<h2><a class="header" href="#位运算" id="位运算">位运算</a></h2>
<h3><a class="header" href="#" id=""><code>&lt;&lt;</code></a></h3>
<p>左移 1 位等于乘以 2，即 <code>4 &lt;&lt; 1 = 8</code>。</p>
<h3><a class="header" href="#-1" id="-1"><code>&gt;&gt;</code></a></h3>
<p>右移 1 位等于除以 2，即 <code>4 &gt;&gt; 1 = 2</code>。</p>
<h1><a class="header" href="#算法分析" id="算法分析">算法分析</a></h1>
<p>所谓<strong>算法</strong>，即特定<strong>计算模型</strong>下，旨在解决特定问题的指令序列。具体来说，其包含以下要素：</p>
<ul>
<li><strong>输入</strong>：待处理的信息（问题）</li>
<li><strong>输出</strong>：经处理的信息（答案）</li>
<li><strong>正确性</strong>：的确可以解决指定的问题</li>
<li><strong>确定性</strong>：任一算法都可以描述为一个由基本操作组成的序列</li>
<li><strong>可行性</strong>：每一基本操作都可实现，且在常数时间内完成</li>
<li><strong>有穷性</strong>：对于任何输入，经有穷次基本操作，都可以得到输出</li>
</ul>
<p>一个好的算法包含以下特性：</p>
<ul>
<li><strong>正确</strong>：符合语法，能够编译、链接</li>
<li><strong>健壮</strong>：能辨别不合法的输入并做适当处理，而不致非正常退出</li>
<li><strong>可读</strong>：结构化 + 准确命名 + 注释 + ...</li>
<li><strong>效率</strong>：速度尽可能快；存储空间尽可能少</li>
</ul>
<p>在本系列文章中，我们重点关注效率方面。</p>
<p>算法分析主要包括两个方面：</p>
<ul>
<li><strong>正确性</strong>：算法功能与问题要求一致？</li>
<li><strong>成本</strong>：运行时间 + 所需存储空间</li>
</ul>
<p>通过挖掘算法的<strong>不变性</strong>和<strong>单调性</strong>可以证明算法的正确性。</p>
<h2><a class="header" href="#大-o-记号" id="大-o-记号">大 O 记号</a></h2>
<p><strong>大 O 记号</strong>（big-O notation）：\(T(n) = O(f(n))\) iff \(\exists c &gt; 0\)，当 \(n &gt;&gt; 2\) 后，有 \(T(n) &lt; c \times f(n)\)</p>
<p>根据以上定义，我们可以得出关于大 O 记号的两个重要处理手法：</p>
<ul>
<li>常系数可忽略：\(O(f(n)) = O(c \times f(n))\)</li>
<li>低次项可忽略：\(O(n^a + n^b) = O(n^a), a &gt; b &gt; 0\)</li>
</ul>
<p>除此之外，还有以下记号：</p>
<ul>
<li>\(T(n) = \Omega(f(n))\)：\(\exists c &gt; 0\)，当 \(n &gt;&gt; 2\) 后，有 \(T(n) &gt; c \times f(n)\)</li>
<li>\(T(n) = \Theta(f(n))\)：\(\exists c_1 &gt; c_2 &gt; 0\)，当 \(n &gt;&gt; 2\) 后，有 \(c_1 \times f(n) &gt; T(n) &gt; c_2 \times f(n)\)</li>
</ul>
<p>根据大 O 记号，我们可以把时间复杂度分为以下几类：</p>
<ul>
<li>\(O(1)\)：常数（constant function）复杂度，这类算法的效率最高，不含转向（循环、调用、递归等），必顺序执行，即是 \(O(1)\)</li>
<li>\(O(logn)\)：对数复杂度，常底数无所谓，常数次幂也无所谓，这类算法非常有效，复杂度无限接近于常数。</li>
<li>\(O(n^c)\)：多项式（polynomial function）复杂度，其中一个特例是线性（\(O(n)\)）复杂度，这类算法的效率通常认为已可令人满意。</li>
<li>\(O(2^n)\)：指数（exponential function）复杂度，这类算法的计算成本增长极快，通常被认为不可忍受。</li>
</ul>
<p>从 \(O(n^c)\) 到 \(O(2^n)\)，是从有效算法到无效算法的分水岭。很多问题的 \(O(2^n)\) 算法往往显而易见，然而，设计出 \(O(n^c)\) 算法却极其不易，甚至，有时注定地只能是徒劳无功。</p>
<p>在最好和最坏情况下，相差极其悬殊的算法，叫<strong>输入敏感</strong>（input-sensitive）的算法，也就是说，它的复杂度具体是多少，与输入时候数据的配置紧密的相关。</p>
<h1><a class="header" href="#封底估算" id="封底估算">封底估算</a></h1>
<p>封底估算即 Back-Of-The-Envelope Calculation。</p>
<p>\(1 天 = 24 hr \times 60 min \times 60 sec \approx 25 \times 4000 = 10^5 sec\)</p>
<p>\(1 生 \approx 1 世纪 = 100 yr \times 365 = 3 \times 10^4 day = 3 \times 10^9 sec\)</p>
<h1><a class="header" href="#线性表" id="线性表">线性表</a></h1>
<p>线性表具体分为顺序表和链表。</p>
<h1><a class="header" href="#顺序表" id="顺序表">顺序表</a></h1>
<p><strong>顺序表</strong>（contiguous list）又称为向量（vector）或数组（array）。</p>
<p>顺序表即物理空间连续的序列，A[i] 的物理地址 = A + i*s，s 为单个元素占用的空间量。</p>
<p>顺序表可分为<strong>无序顺序表</strong>和<strong>有序顺序表</strong>。</p>
<h2><a class="header" href="#扩容" id="扩容">扩容</a></h2>
<p>相比递增式扩容，采用加倍式扩容，每次扩容的分摊成本仅为 \(O(1)\)，而递增式扩容每次扩容的分摊成本则为 \(O(n)\)。</p>
<h2><a class="header" href="#无序顺序表" id="无序顺序表">无序顺序表</a></h2>
<p>无序顺序表要求元素之间至少应该能比较是否相等，我们称作<strong>比对</strong>操作。</p>
<h3><a class="header" href="#无序顺序表的去重" id="无序顺序表的去重">无序顺序表的去重</a></h3>
<p>Python 实现：</p>
<pre><code class="language-python">def deduplicate(lis):  # 删除重复元素，返回被删除元素数目
    old_size = len(lis)  # 记录原规模
    i = 1  # 从lis[1]开始
    while i &lt; len(lis):  # 自前向后逐一考察各元素lis[i]
        try:
            lis[:i].index(lis[i])  # 在前缀中寻找雷同者
            lis.pop(i)  # 若有雷同则删除雷同者（至多一个？！）
        except ValueError:
            i += 1  # 否则继续考察其后继
    return old_size-len(lis)  # 顺序表规模变化量，即删除元素总数


# 测试
lis = [3, 3, 3, 1, 9, 8, 7, 2, 1, 2]
print(deduplicate(lis))  # 4
</code></pre>
<p>对于规模为 n 的顺序表，其最坏时间复杂度为 \(O(n^2)\)。</p>
<h2><a class="header" href="#有序顺序表" id="有序顺序表">有序顺序表</a></h2>
<p>有序顺序表要求能够判定任何一对元素孰大孰小，我们称作<strong>比较</strong>操作。</p>
<p>无序顺序表经预处理转换为有序顺序表之后，相关算法多可优化。</p>
<h3><a class="header" href="#有序性" id="有序性">有序性</a></h3>
<p><em>有序</em> 序列中，<em>任意</em> 一对相邻元素 <em>顺序</em>；<em>无序</em> 序列中，<em>总有</em> 一对相邻元素 <em>逆序</em>。因此，相邻逆序对的数目，可用以度量顺序表的逆序程度。</p>
<p>注意：<strong>相邻逆序对</strong>即两个相邻的元素 <code>{..i, j..}</code> 且 <code>i&gt;j</code>。而<strong>逆序数</strong>是逆序对的个数，并不要求二者相邻。</p>
<pre><code class="language-python">def disordered(lis):  # 返回逆序相邻元素对的总数
    n = 0  # 计数器
    for i in range(1, len(lis)):  # 逐一检查各对相邻元素
        n += (lis[i-1] &gt; lis[i])  # 逆序则计数
    return n  # 向量有序当且仅当n=0


# 测试
lis = [3, 3, 3, 1, 9, 8, 7, 2, 1, 2]
print(disordered(lis))  # 5
</code></pre>
<p>若只需判断是否有序，则首次遇到逆序对之后，即可立即终止。</p>
<h3><a class="header" href="#有序顺序表的去重" id="有序顺序表的去重">有序顺序表的去重</a></h3>
<p>在有序顺序表中，重复的元素必然相互紧邻构成一个区间，因此，每一区间只需保留单个元素即可。</p>
<p>Python 实现：</p>
<pre><code class="language-python">def uniquify(lis):
    i = 0
    j = 1  # 各对互异“相邻”元素的秩
    while j &lt; len(lis):  # 逐一扫描，直至末元素
        if lis[i] != lis[j]:  # 跳过雷同者；发现不同元素时，向前移至紧邻于前者右侧
            i += 1
            lis[i] = lis[j]
        j += 1
    i += 1  # 直接截除尾部多余元素
    return j-i  # 顺序表规模变化量，即被删除元素总数


# 测试
lis = [1, 1, 2, 2, 3, 3, 3, 7, 8, 9]
print(uniquify(lis))  # 4
</code></pre>
<p>C 语言实现：</p>
<pre><code class="language-c">int removeDuplicates(int* nums, int numsSize)
{
    if(numsSize == 0)
    {
        return 0;
    }
    int i = 0, j = 0;
    while(++j &lt; numsSize)
    {
        if(nums[i] != nums[j])
        {
            nums[++i] = nums[j];
        }
    }
    return ++i
}
</code></pre>
<p>对于规模为 n 的顺序表，其最坏时间复杂度为 \(O(n)\)。</p>
<p>LeetCode：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除排序数组中的重复项</a></p>
<h2><a class="header" href="#语言实现" id="语言实现">语言实现</a></h2>
<p>在 Python 中可以使用内置的 list 来实现顺序表的功能，如下：</p>
<pre><code class="language-python">contiguous_list = []
# 增加
contiguous_list.insert(0, 5)
contiguous_list.insert(0, 6)
contiguous_list.insert(2, 9)
contiguous_list.insert(3, 5)
# 删除
contiguous_list.pop(1)
# 查找
contiguous_list[0]
# 去重
contiguous_list = list(set(contiguous_list))
# 反转
contiguous_list.reverse()
</code></pre>
<h1><a class="header" href="#链表" id="链表">链表</a></h1>
<p><strong>链表</strong>（linked list）又称为列表（list）。</p>
<p>链表即物理空间不连续的线性序列，其中的元素称作<strong>节点</strong>（node），各节点通过指针或引用彼此连接，在<strong>逻辑</strong>上构成一个线性序列。</p>
<p>相邻节点彼此互称<strong>前驱</strong>（predecessor）或<strong>后继</strong>（successor），前驱或后继若存在，则必然唯一，没有前驱的唯一节点称作<strong>首</strong>（first/front）节点，没有后继的唯一节点称作<strong>末</strong>（last/rear）节点。</p>
<pre><code class="language-python">class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class List:
    pass
</code></pre>
<h2><a class="header" href="#查找" id="查找">查找</a></h2>
<h2><a class="header" href="#增加" id="增加">增加</a></h2>
<h2><a class="header" href="#删除" id="删除">删除</a></h2>
<p>LeetCode：<a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></p>
<h1><a class="header" href="#栈" id="栈">栈</a></h1>
<p>栈（stack）</p>
<p>栈的这种特性也可以被称为<strong>后进先出</strong>（LIFO，Last In First Out）。</p>
<p>在 Python 中可以使用内置的 list 来实现栈的功能，如下：</p>
<pre><code class="language-python">stack = []
stack.append(1)  # 入栈
stack.append(2)  # 入栈
stack.pop()  # 出栈
stack.pop()  # 出栈
</code></pre>
<h1><a class="header" href="#队列" id="队列">队列</a></h1>
<p><strong>队列</strong>（queue）也是<strong>受限</strong>的序列，其只能在队尾插入（enqueue），只能在对头删除（dequeue）。</p>
<p>队列的这种特性也可以被称为<strong>先进先出</strong>（FIFO，First In First Out）。</p>
<p>在 Python 中可以使用内置的 collections.deque 来实现队列的功能，如下：</p>
<pre><code class="language-python">from collections import deque

queue = deque()
queue.append(1)  # 入队
queue.append(2)  # 入队
queue.popleft()  # 出队
queue.popleft()  # 出队
</code></pre>
<h1><a class="header" href="#树" id="树">树</a></h1>
<p>前面已经介绍了顺序表和链表这两种线性数据结构，我们来对比一下在其上执行操作的时间复杂度：</p>
<table><thead><tr><th>操作</th><th>顺序表</th><th>链表</th></tr></thead><tbody>
<tr><td>静态操作：查找</td><td>\(O(logn)\)</td><td>\(O(n)\)</td></tr>
<tr><td>动态操作：增加/删除</td><td>\(O(n)\)</td><td>\(O(1)\)</td></tr>
</tbody></table>
<p>树结构则是将顺序表和链表的优势结合起来，可以理解为链表的链表，也可以认为是二维的链表，由于这个原因，可以认为树型结构既不是我们此前所介绍的线性数据结构，同时它也带有一定的线性特征，为了与之后的非线性数据结构 —— 图相区别，我们不妨称其为<strong>半线性数据结构</strong>。</p>
<p>树是用来按照层次关系组织一系列数据项的一种方式。</p>
<h2><a class="header" href="#定义递归嵌套" id="定义递归嵌套">定义：递归嵌套</a></h2>
<p>树是特殊的图 \(T=(V, E)\)，节点数（vertex）\(|V|=n\)，边数（edge）\(|E|=e\)。</p>
<p>指定任一节点 \(r\in V\) 作为根后，\(T\) 即称作<strong>有根树</strong>（rooted tree）。</p>
<p>通过彼此的嵌套，小型的有根树可以逐步地整合为规模更大的有根树。即若 \(T_1,T_2,...T_d\) 为有根树，则 \(T=((\cup V_i) \cup { r } ,)\) 也是。相对于 \(T\)，\(T_i\) 称作以 \(r_i\) 为根的<strong>子树</strong>（subtree rooted at \(r_i\)），记作 \(T_i=subtree(r_i)\)。\(r_i\) 称作 \(r\) 的<strong>孩子</strong>（child），\(r_i\) 之间互称<strong>兄弟</strong>（sibling）。\(r\) 为其<strong>父亲</strong>（parent），\(d=degree(r)\) 为 \(r\) 的（出）<strong>度</strong>（degree），即 \(r\) 的孩子的数目。</p>
<p>可归纳证明：\(e=\sum_{r\in V} degree(r)=n-1=\Theta(n)\)，即任何一棵树中，所含的边数（\(e\)）应该恰好等于其中所有顶点的度数之和，同时也恰好等于顶点总数（\(n\)）减 1，故在衡量相关复杂度时，可以 \(n\) 作为参照。</p>
<p>若指定 \(T_i\) 作为 \(T\) 的第 \(i\) 棵子树，\(r_i\) 作为 \(r\) 的第 \(i\) 个孩子，则 \(T\) 称作<strong>有序树</strong>（ordered tree）。</p>
<h2><a class="header" href="#定义连通性无环性" id="定义连通性无环性">定义：连通性+无环性</a></h2>
<p>\(V\) 中的 \(k+1\) 个节点，通过 \(E\) 中 \(k\) 条边依次相联，构成一条<strong>路径</strong>（path），亦称<strong>通路</strong>。表示为：
\[\pi=\{(v_0, v_1), (v_1, v_2), ..., (v_{k-1}, v_k)\}\]</p>
<p>其中路径<strong>长度</strong>：\(|\pi|=边数=k\)。在早期文献中，或以节点数为长度。</p>
<p>所谓<strong>环路</strong>（cycle/loop），即 \(v_k=v_0\)</p>
<p>节点之间均有路径，称作<strong>连通图</strong>（connected）。不含环路，称作<strong>无环图</strong>（acyclic）。</p>
<p>所谓的树，其实就是在无环与连通之间达到一个平衡的一种特定的图，因为无环，所以它的边数不会太大，反之，因为连通，所以它的边数又不能太少（<strong>无环连通图</strong>）；在保证连通的前提下，它的边数能够达到最少（<strong>极小连通图</strong>）；而在杜绝环路的前提下，它又能够使用尽可能多的边（<strong>极大无环图</strong>）。</p>
<p>从以上可得，任一节点 \(v\) 与根之间存在<strong>唯一</strong>路径，即 \(path(v, r)=path(v)\)，因此每一个节点拥有了一个唯一的指标，也就是这条路径的长度。</p>
<p>不致歧义时，路径、节点和子树可相互指代，即 \(path(v)\sim v\sim subtree(v)\)，因此，\(v\) 的<strong>深度</strong>：\(depth(v)=|path(v)|\)。</p>
<p>此外，\(path(v)\) 上节点，均为 \(v\) 的<strong>祖先</strong>（ancestor），\(v\) 是它们的<strong>后代</strong>（descendent），其中，除自身以外，是<strong>真</strong>（proper）祖先/后代。</p>
<p>所谓的半线性，即在任一深度，\(v\) 的祖先若存在，则<strong>必然</strong>唯一；\(v\) 的后代若存在，则<strong>未必</strong>唯一。</p>
<p>根节点是所有节点的<strong>公共祖先</strong>，深度为 0，没有后代的节点称作<strong>叶子</strong>（leaf），所有叶子深度中的最大者称作（子）树（根）的<strong>高度</strong>，即 \(height(v)=height(subtree(v))\)。</p>
<p>特别地，空树的高度取做 -1。</p>
<p>任何一个节点的高度与深度之和绝对不会超过全树的高度，即 \(depth(v)+height(v)\leq height(T)\)。</p>
<h2><a class="header" href="#表示" id="表示">表示</a></h2>
<p>为兼顾空间性能和时间性能，通常采用<strong>长子-兄弟</strong>表示法表示一棵树。即每个节点均设两个引用：纵（<code>firstChild()</code>）和横（<code>nextSibling()</code>）。</p>
<h1><a class="header" href="#二叉树" id="二叉树">二叉树</a></h1>
<p>节点度数<strong>不超过 2</strong> 的树称作<strong>二叉树</strong>（binary tree）。</p>
<p>同一节点的孩子和子树，均以<strong>左</strong>、<strong>右</strong>区分，其中隐含有序。</p>
<p>深度为 \(k\) 的节点，至多 \(2^k\) 个。</p>
<p>含 \(n\) 个节点、高度为 \(h\) 的二叉树中：\(h\lt n\lt 2^{h+1}\)：</p>
<ul>
<li>\(n=h+1\) 时：退化为一条单链</li>
<li>\(n=2^{h+1}-1\) 时：即所谓<strong>满二叉树</strong>（full binary tree）</li>
</ul>
<p>每个节点的度数都是偶数（或者是 0 或者是 2）的树称作<strong>真二叉树</strong>（full binary tree）。</p>
<p>二叉树是多叉树的特例，但在有根且有序时，其描述能力却足以覆盖后者。利用长子-兄弟表示法，多叉树均可转化并表示为二叉树。</p>
<pre><code class="language-python">class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class BinTree:
    pass
</code></pre>
<h2><a class="header" href="#深度优先遍历" id="深度优先遍历">深度优先遍历</a></h2>
<p>二叉树的深度优先遍历具体分为：</p>
<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
</ul>
<p>前序、中序、后序是相对于根的访问顺序确定的。</p>
<h3><a class="header" href="#前序遍历" id="前序遍历">前序遍历</a></h3>
<p>前序遍历（preorder traversal）又称先序遍历，指先访问根，然后访问子树的遍历方式</p>
<pre><code class="language-python">class Solution:
    def visit_along_left_branch(self, root: TreeNode, stack, result):
        while root:
            result.append(root.val)
            stack.append(root.right)
            root = root.left

    # 迭代实现
    def preorder_traversal(self, root: TreeNode) -&gt; List[int]:
        stack = []
        result = []
        while True:
            self.visit_along_left_branch(root, stack, result)
            if not stack:
                break
            root = stack.pop()
        return result

    # 递归实现
    def preorder_traversal_recursion(self, root: TreeNode) -&gt; List[int]:
        result = []
        if not root:
            return
        result.append(root.val)
        self.preorder_traversal_recursion(root.left)
        self.preorder_traversal_recursion(root.right)
        return result
</code></pre>
<p>LeetCode：<a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></p>
<h3><a class="header" href="#中序遍历" id="中序遍历">中序遍历</a></h3>
<p>中序遍历（inorder traversal）指先访问左（右）子树，然后访问根，最后访问右（左）子树的遍历方式</p>
<p>如果二叉树画的规范的话，那么它的<strong>垂直投影</strong>则是中序遍历序列。</p>
<pre><code class="language-python">class Solution:
    def go_along_left_branch(self, root: TreeNode, stack):
        while root:
            stack.append(root)
            root = root.left

    # 迭代实现
    def inorder_traversal(self, root: TreeNode) -&gt; List[int]:
        stack = []
        result = []
        while True:
            self.go_along_left_branch(root, stack)
            if not stack:
                break
            root = stack.pop()
            result.append(root.val)
            root = root.right
        return result
</code></pre>
<p>LeetCode：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></p>
<h3><a class="header" href="#后序遍历" id="后序遍历">后序遍历</a></h3>
<p>后序遍历（postorder traversal）指先访问子树，然后访问根的遍历方式</p>
<pre><code class="language-python">class Solution:
    def goto_left_most_leaf(self, stack):
        while (root=stack.pop()):
            stack.append(root)
            root = root.left

    # 迭代实现
    def postorder_traversal(self, root: TreeNode) -&gt; List[int]:
        stack = []
        result = []
        if root:
            stack.append(root)
        while stack:
            if stack.top() != root.parent:
                self.go_along_left_branch(stack)
            root = stack.pop()
            result.append(root.val)
        return result
</code></pre>
<p>LeetCode：<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></p>
<h2><a class="header" href="#广度优先遍历" id="广度优先遍历">广度优先遍历</a></h2>
<p>二叉树的广度优先遍历即层序遍历/层次遍历。</p>
<pre><code class="language-python">from collections import deque


class Solution:
    # 迭代实现
    def level_order_traversal(self, root: TreeNode) -&gt; List[int]:
        result = []
        queue = deque()  # 引入辅助队列
        queue.append(root)  # 根节点入队
        while queue:  # 在队列再次变空之前，反复迭代
            x = queue.popleft()  # 取出队首节点，并随即
            result.append(x.val)  # 访问之
            if x.left:
                queue.append(x.left)  # 左孩子入队
            if x.right:
                queue.append(x.right)  # 右孩子入队
        return result
</code></pre>
<p>LeetCode：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></p>
<h2><a class="header" href="#重构" id="重构">重构</a></h2>
<p>已知 <em>前序遍历与后序遍历之一</em> 以及 <em>中序遍历</em>，可以重构出一棵二叉树。</p>
<p>已知 <em>前序遍历</em> 以及 <em>后序遍历</em>，可以重构出一颗真二叉树。</p>
<h1><a class="header" href="#二叉搜索树" id="二叉搜索树">二叉搜索树</a></h1>
<p>如果说二叉树是对链表的扩充，那么二叉搜索树则可以看作是对有序顺序表的扩充。</p>
<p>在二叉搜索树中，数据项之间，依照各自的<strong>关键码</strong>（key）彼此区分。因此，这种访问方式不妨称之为<strong>寻关键码访问</strong>（call-by-key）。</p>
<p><strong>二叉搜索树</strong>（Binary Search Tree，<strong>BST</strong>）相比二叉树拥有以下特性：</p>
<ul>
<li><strong>顺序性</strong>（局部特征）：任一节点均<strong>大于</strong>其<strong>左</strong>后代，任一节点均<strong>小于</strong>其<strong>右</strong>后代</li>
<li><strong>单调性</strong>（全局特征）：BST 的<strong>中序</strong>遍历序列，必然<strong>单调</strong>非降</li>
</ul>
<h2><a class="header" href="#查找-1" id="查找-1">查找</a></h2>
<p>二叉搜索树的查找运用了减治法的思想，即从根节点出发，逐步地缩小查找范围，直到发现目标（成功），或查找范围缩小至空树（失败）。</p>
<p>对照中序遍历序列可见，整个过程可视作是在仿效有序顺序表的二分查找。</p>
<p>最坏时间复杂度为 \(O(h)\)，\(h\) 为树的高度。</p>
<h2><a class="header" href="#增加-1" id="增加-1">增加</a></h2>
<p>先借助查找算法确定插入位置及方向，再将新节点作为叶子插入。</p>
<p>其时间复杂度主要取决于查找算法，故最坏时间复杂度为 \(O(h)\)，\(h\) 为树的高度。</p>
<h2><a class="header" href="#删除-1" id="删除-1">删除</a></h2>
<p>删除算法稍微复杂，因为这不是简单的删除，还要保证删除后仍然是一棵二叉搜索树，假设要删除的目标节点为 \(x\)，可分以下两种情况考虑：</p>
<ul>
<li>若 \(x\) 的某一子树为空，则可将其替换为另一子树。</li>
<li>若 \(x\) 有两棵子树，则可化繁为简，令 \(x\) 和它的直接后继互换，此时 \(x\) 将至多有一个右孩子（因为此节点是直接后继，它必然是某条左侧分支的末端），此时可采用上一种情况的方法。</li>
</ul>
<pre><code class="language-python">
</code></pre>
<p>最坏时间复杂度为 \(O(h)\)，\(h\) 为树的高度。</p>
<p>LeetCode：<a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></p>
<h1><a class="header" href="#平衡二叉搜索树" id="平衡二叉搜索树">平衡二叉搜索树</a></h1>
<p>由前文可知，二叉搜索树的所有操作的时间复杂度为 \(O(h)\)，\(h\) 为树的高度，然而，其平均高度为 \(O(\sqrt n)\)，这并不能令人满意，因此我们要试图降低树的高度。</p>
<p>节点数目固定时，兄弟子树高度越接近（平衡），全树也将倾向于更低。</p>
<p>由 \(n\) 个节点组成的二叉树，高度不低于 \(\lfloor log_2 n \rfloor\) —— 恰为 \(\lfloor log_2 n \rfloor\) 时，称作<strong>理想平衡</strong>。</p>
<p>完全二叉树、满二叉树都是理想平衡的。</p>
<p>理想平衡出现概率极低、维护成本过高，故须适当地放松标准。</p>
<p>高度渐进地不超过 \(O(logn)\)，即可称作<strong>适度平衡</strong>。适度平衡的 BST，称作<strong>平衡二叉搜索树</strong>（Balanced Binary Search Tree，<strong>BBST</strong>）。</p>
<p>也就是说，BBST 是 BST 的一个子集，如果经过某些操作（一般为动态操作）之后，它不再保持适度平衡，就会游离这个子集之外，此时，我们就需要一整套方法将它重新拉回这个子集之内，这叫做<strong>重平衡</strong>（rebalance）。不同的 BBST（比如 AVL 树、伸展树、红黑树等），它们的适度平衡的标准不一样，重平衡方法也不一样。无论哪种重平衡方法，本质上来说都是一系列的<strong>等价变换</strong>。</p>
<p>拓扑结构不尽相同，但中序遍历序列却相同的任何一对 BST，称作相互等价的 BST。等价的 BST 之间，在拓扑结构上虽然不尽相同，但也有其独特的规律：</p>
<ul>
<li>上下可变：联接关系不尽相同，承袭关系可能颠倒。即等价的 BST 在垂直方向有一定的自由度。</li>
<li>左右不乱：中序遍历序列完全一致，全局单调非降</li>
</ul>
<p>实际上，任何一对等价 BST 之间的相互转换，都可以视作是由一系列的基本操作串接而成，而这种基本的变换无非两类，彼此对称，即 zig（顺时针旋转）和 zag（逆时针旋转）。</p>
<h1><a class="header" href="#avl-树" id="avl-树">AVL 树</a></h1>
<p>对于二叉树中的任何一个节点 \(v\)，它的平衡因子就是它的左子树高度与右子树高度之差，即：</p>
<p>\(balFac(v)=height(lc(v)) - height(rc(v))\)</p>
<p>所谓 <strong>AVL 树</strong>就是其中所有节点的平衡因子都不超过 1 也不小于 -1，即：</p>
<p>\(\forall v,|balFac(v)|\leq 1\)</p>
<h2><a class="header" href="#增加-2" id="增加-2">增加</a></h2>
<p>增加算法稍微简单，无非就是<strong>单旋</strong>或<strong>双旋</strong>两种情况而已。</p>
<p>其重平衡的时间复杂度为 \(O(1)\)。</p>
<h2><a class="header" href="#删除-2" id="删除-2">删除</a></h2>
<p>因有失衡传播现象，可能需做 \(O(logn)\) 次调整。</p>
<h1><a class="header" href="#伸展树" id="伸展树">伸展树</a></h1>
<h1><a class="header" href="#红黑树" id="红黑树">红黑树</a></h1>
<p>由红、黑两类节点组成的 BST（统一增设外部节点 NULL，使之成为真二叉树）：</p>
<ul>
<li>树根：必为黑色</li>
<li>外部节点：均为黑色</li>
<li>其余节点：若为红，则只能有黑孩子。即红之子、之父必黑</li>
<li>外部节点到根：途中黑节点数目相等。即黑深度</li>
</ul>
<p>提升各红节点，使之与其（黑）父亲等高 —— 于是每棵红黑树，都对应于一棵 (2, 4) 树。</p>
<h2><a class="header" href="#增加-3" id="增加-3">增加</a></h2>
<h2><a class="header" href="#删除-3" id="删除-3">删除</a></h2>
<h1><a class="header" href="#b-树" id="b-树">B 树</a></h1>
<p>相比二叉搜索树，<strong>B 树</strong>（B-tree）或称 B-树中每一个节点未必只有两个分叉（实际上，可以拥有更多的分叉），其次，所有底层节点的深度都是完全一致的，从这个意义上讲，它不失为一种理想平衡的搜索树。</p>
<p>从整体上看，B 树会显得更宽、更矮。</p>
<p>由于 B 树也属于平衡搜索树，所以它也具有某种方法来自平衡。</p>
<p>B 树可以理解为是平衡的多路（multi-way）搜索树。</p>
<p>若将多路搜索树中的每一个节点称作<strong>超级节点</strong>，那么每一个超级节点都可以看成是由若干个二路节点经过适当的合并以后得到的，具体来说：</p>
<ul>
<li>每 2 代合并：4 路</li>
<li>每 3 代合并：8 路</li>
<li>...</li>
<li>每 \(d\) 代合并：\(m=2^d\) 路，\(m-1\) 个关键码</li>
</ul>
<p>从上可以看出，B 树在逻辑上与 BBST 完全等价。但 B 树也有其存在的原因，具体来说，多级存储系统中使用 B 树，可针对外部查找，大大减少 I/O 次数。</p>
<p>我们知道，二叉搜索树的查找的逐层递进的，其最坏时间复杂度为 \(O(h)\)，\(h\) 为树的高度，注意这里每访问一层实际上就是一次 I/O 操作，对于平衡二叉搜索树来说，它会适当的降低树的高度，以尽量减小最坏时间复杂度，以 AVL 树为例，若有 \(n=10^9=1G\) 个记录，那么每次查找需要 \(log_2 10^9=30\) 次 I/O 操作，每次只读出一个关键码，得不偿失。</p>
<p>对于以上情况，若使用 B 树，则能充分利用外存对批量访问的高效支持，将此特点转化为优点，每下降一层，都以超级节点为单位，读入一组关键码。</p>
<p>所谓 \(m\) 阶 B 树，即 \(m\) 路平衡搜索树（\(m&gt;=2\)）。</p>
<p>阶次 \(m\) 给出了 B 树中每个超级节点规模的上限和下限（以 \(n\) 来表示节点中所含的关键码数）：</p>
<ul>
<li>上限：内部节点各有
<ul>
<li>不超过 \(m\) 个分支：\(A_0,A_1,A_2,...,A_n\)</li>
<li>不超过 \(m-1\) 个关键码：\(K_1&lt;K_2&lt;...&lt;K_n\)</li>
</ul>
</li>
<li>下限：内部节点的分支数 \(n+1\) 也不能太少
<ul>
<li>其余：\(\lceil m/2\rceil\leq n+1\)</li>
<li>树根：\(2\leq n+1\)</li>
</ul>
</li>
</ul>
<p>既然如此，我们也用超级节点所拥有分支数的下限和上限来命名 B 树，故亦称作 (\(\lceil m/2\rceil,m\)) 树。比如 \(m=5\) 时，每个节点的分支数自然不得超过 5，同时一般节点所拥有的分支数也不得少于 3，所以我们也可以称之为 (3, 5) 树。特别的，对于 4 阶 B 树而言，自然也可以称之为 (2, 4) 树，(2, 4) 树在 B 树中具有非常独特的作用和地位，(2, 4) 树与红黑树有不解的渊源。</p>
<h2><a class="header" href="#查找-2" id="查找-2">查找</a></h2>
<h2><a class="header" href="#增加-4" id="增加-4">增加</a></h2>
<h2><a class="header" href="#删除-4" id="删除-4">删除</a></h2>
<h1><a class="header" href="#b-树-1" id="b-树-1">B+ 树</a></h1>
<h1><a class="header" href="#图" id="图">图</a></h1>
<p>相对于此前的线性以及半线性结构，图结构对其中元素的限定更少，因此反过来，它描述应用问题的能力也就更强。</p>
<p>与树类似：</p>
<p>\(G=(V; E)\)</p>
<p>vertex：\(n=|V|\)</p>
<p>edge|arc：\(e=|E|\)</p>
<p>存在连边的任何两个点都称作是彼此邻接的，那么这样一个关系，也称作<strong>邻接</strong>（adjancency）关系，而参与定义这种邻接关系的每一个顶点，与这个邻接关系之间的关系，我们也称作<strong>关联</strong>（jncidence）关系。形象地说，所谓的邻接关系就是顶点与顶点之间的关系，而关联关系实际上是描述顶点以及与它相关的某条边之间的关系。</p>
<p>若同一个节点与自身构成一个邻接关系，则称作<strong>自环</strong>，本节不讨论这种情况。</p>
<p>若邻接顶点 \(u\) 和 \(v\) 的次序无所谓，则 \((u, v)\) 为<strong>无向边</strong>（undirected edge）。例：若 \(u\) 是 \(v\) 的好友，则 \(v\) 也必是 \(u\) 的好友。</p>
<p>所有边均无方向的图，即<strong>无向图</strong>（undigraph）。</p>
<p>反之，<strong>有向图</strong>（digraph）中<strong>均</strong>为<strong>有向边</strong>（directed edge），\(u\)、\(v\) 分别称作边 \((u, v)\) 的<strong>尾</strong>（tail）、<strong>头</strong>（head）。例：“\(u\) 欠 \(v\) 的钱”与“\(v\) 欠 \(u\) 的钱”。</p>
<p>在有些情况下，图中的边有的是有向的，而另一部分却可能是无向的，这样的图称之为<strong>混合图</strong>（mixed graph）</p>
<p>本节重点研究有向图，因为通过有向图，完全可以表示并且实现无向图以及混合图。</p>
<p>与树类似：</p>
<p>路径 \(\pi=&lt;v_0, v_1, ..., v_k&gt;\)，长度 \(|\pi|=k\)</p>
<p><strong>简单路径</strong>（simple path）：\(v_i=v_j\) 除非 \(i=j\)</p>
<p>环/<strong>环路</strong>：\(v_0=v_k\)</p>
<p>如果在一个有向图中，不包含任何的环路，则称之为<strong>有向无环图</strong>（DAG）。</p>
<p>经过所有的边一次而且恰好一次的环路称作<strong>欧拉环路</strong>（Eulerian tour）；对称的，经过每一个顶点一次而且恰好一次的环路称作<strong>哈密尔顿环路</strong>（Hamiltonian tour）。</p>
<p>一笔画问题即要找出欧拉路径。</p>
<h2><a class="header" href="#邻接矩阵" id="邻接矩阵">邻接矩阵</a></h2>
<p>图的表示可以采用<strong>邻接矩阵</strong>或<strong>关联矩阵</strong>来表示，本节我们主要采用邻接矩阵。</p>
<p>所谓邻接矩阵就是用以描述顶点之间相互邻接关系的一种形式，具体来说，这是一个方阵，如果图中包含 \(n\) 个顶点，这个矩阵也就是 \(n\times n\) 的，于是矩阵中的任何一个单元，比如对应于第 \(i\) 行第 \(j\) 列的那个单元，都表示顶点 \(i\) 与顶点 \(j\) 之间是否存在一条边（即是否关联）。</p>
<p>如果是无向图，那么它对应的邻接矩阵就应该是对称的，特别的，在该矩阵对角线上的元素都对应于自环。</p>
<p>如果是带权图（即网络），那么每个单元可以存储权值。</p>
<p>对于关联矩阵，如果当前的图有 \(n\) 个节点，那么这个矩阵就有 \(n\) 行，如果图中总共包含 \(e\) 条边，那么这个矩阵就对应的有 \(e\) 列，相应地，矩阵中的任何一个单元表示的也就是对应的顶点与对应的边之间。对于矩阵中的任何一列而言，应该恰好有两个单元的数值为 1，而其余的都是 0。</p>
<h2><a class="header" href="#广度优先搜索" id="广度优先搜索">广度优先搜索</a></h2>
<h2><a class="header" href="#深度优先搜索" id="深度优先搜索">深度优先搜索</a></h2>
<h1><a class="header" href="#哈希表" id="哈希表">哈希表</a></h1>
<h2><a class="header" href="#概念" id="概念">概念</a></h2>
<p><strong>哈希表</strong>（hash table）又称字典（dictionary）、词典或散列表，<strong>哈希</strong>（hashing）又称散列或杂凑。</p>
<p>当我们需要存储和组织的数据项可能来自于一个相当大的空间（不妨将其数量记为 R），而在任何一个常规的时刻，我们所真正需要存储和组织的数据只是其中非常非常小的一个子集时（不妨将其数量记为 N），为了提升空间效率，就需要使用哈希表。</p>
<p>哈希表中的每一个单元被称为<strong>桶</strong>（bucket），其可以 <em>直接存放</em> 或 <em>间接指向</em> 一个词条（entry）。因此，哈希表又可称为桶数组（bucket array）。</p>
<p><strong>定址</strong>（或哈希）是指根据词条的 key（未必可比较）直接确定哈希表入口。要实现这种定址就需要<strong>哈希函数</strong>/散列函数。</p>
<p>为方便讨论，我们将哈希表的长度（即容量）记为 M。</p>
<p>已用空间的容量与哈希表总容量之比，即 N/M，称为<strong>装填因子</strong>（load factor），通常也简记为 \(\lambda\)。</p>
<p>哈希冲突/散列冲突（hash collision），即存在 key1 != key2，但 hash(key1) = hash(key2)。适当的将哈希表的长度增长，可以减少冲突出现的概率。</p>
<p>从理论上讲，哈希可以看作是由一个大空间到小空间的映射，因此绝不可能是单射，即冲突不可避免，但是，近似的单射往往可行，因此，我们需要：</p>
<ul>
<li>精心设计哈希表及哈希函数，以尽可能降低冲突的概率；</li>
<li>更需要制定可行的预案，以便在发生冲突时，能够尽快予以排解。</li>
</ul>
<p>下面两节将分别介绍。</p>
<h2><a class="header" href="#哈希函数" id="哈希函数">哈希函数</a></h2>
<p>一个好的哈希函数有以下特性：</p>
<ul>
<li><strong>确定</strong>（determinism）：同一关键码总是被映射至同一地址</li>
<li><strong>快速</strong>（efficiency）：\(expected-O(1)\)</li>
<li><strong>满射</strong>（surjection）：尽可能充分地覆盖整个哈希空间</li>
<li><strong>均匀</strong>（uniformity）：关键码映射到哈希表各位置的概率尽量接近，可有效避免聚集（clustering）现象。</li>
</ul>
<p>以下是一些常用的哈希函数：</p>
<h3><a class="header" href="#除余法" id="除余法">除余法</a></h3>
<p>\(hash(key) = key \bmod M\)，M 为素数时，数据对哈希表的覆盖最充分，分布最均匀。</p>
<p>除余法的缺陷：</p>
<ul>
<li><strong>不动点</strong>：无论表长 M 取值如何，总有 hash(0) = 0</li>
<li><strong>零阶均匀</strong>：[0, k) 的关键码，平均分配至 M 个桶；但相邻关键码的哈希地址也必相邻</li>
</ul>
<h3><a class="header" href="#mad-法" id="mad-法">MAD 法</a></h3>
<p>MAD 即 multiply-add-divide（乘-加-除），取 M 为素数，\(a &gt; 0\)，\(b &gt; 0\)，\(a \bmod M \neq 0\)，\(hash(key) = (a \times key + b) \bmod M\)。</p>
<p>MAD 法可以解决上述除余法的两个缺陷：</p>
<ul>
<li>b 可以看作是偏移量（offset），可解决不动点问题</li>
<li>a 可以看作是步长（step），可以实现<strong>一阶均匀</strong>，即邻近的关键码，哈希地址不再邻近</li>
</ul>
<p>当然，特定场合下，未必需要高阶的均匀性。</p>
<h3><a class="header" href="#数字分析法selecting-digits" id="数字分析法selecting-digits">数字分析法（selecting digits）</a></h3>
<p>抽取 key 中的某几位，构成地址。</p>
<p>比如，取十进制表示的奇数位：\(hash(123456789) = 13579\)</p>
<p>此方法的缺陷在于没有被选用的那一组数位，对最终的哈希地址没有任何影响和贡献，没有足够的体现均匀性的要求。</p>
<h3><a class="header" href="#平方取中法mid-square" id="平方取中法mid-square">平方取中法（mid-square）</a></h3>
<p>取 \(key^2\) 的中间若干位，构成地址。</p>
<p>比如：</p>
<p>\(hash(123)=512\)，保留 \(key^2=123^2=15129\) 的中间 3 位</p>
<p>\(hash(1234567)=556\)，保留 \(1234567^2=1524155677489\) 的中间 3 位</p>
<p>平方取中法可以有效的解决上述方法的缺陷，取中间的数位可以使得构成原关键码的各数位能够对最终的哈希地址有尽可能接近的影响。</p>
<h3><a class="header" href="#折叠法folding" id="折叠法folding">折叠法（folding）</a></h3>
<p>将 key 分割成等宽的若干段，取其总和作为地址。</p>
<h3><a class="header" href="#位异或法-xor" id="位异或法-xor">位异或法 XOR</a></h3>
<p>将 key 分割成等宽的二进制段，经异或运算得到地址。</p>
<p>总之，哈希函数越是随机，越是没有规律，越好。</p>
<h2><a class="header" href="#排解冲突" id="排解冲突">排解冲突</a></h2>
<p>哈希表中的冲突无法避免，通过以下方法可以排解冲突：</p>
<h3><a class="header" href="#多槽位" id="多槽位">多槽位</a></h3>
<p><strong>多槽位</strong>（multiple slots）：桶单元细分成若干槽位（slot），存放（与同一单元）冲突的词条。</p>
<p>只要槽位数目不多，依然可以保证 \(O(1)\) 的时间效率。</p>
<p>但是，需要为每个桶配备多少个槽，方能保证 \(O(1)\)？若预留过多，则空间浪费；无论预留多少，极端情况下仍有可能不够。</p>
<h3><a class="header" href="#独立链" id="独立链">独立链</a></h3>
<p>为了解决以上问题，可以采用独立链法。</p>
<p><strong>独立链</strong>（linked-list chaining/separate chaining）：每个桶存放一个指针，冲突的词条，组织成链表。</p>
<p>它存在如下优点与缺点：</p>
<p>优点：</p>
<ul>
<li>无需为每个桶预备多个槽位</li>
<li>任意多次的冲突都可解决</li>
<li>删除操作实现简单、统一</li>
</ul>
<p>缺点：</p>
<ul>
<li>指针需要额外空间</li>
<li>节点需要动态申请</li>
<li>空间未必连续分布，系统缓存几乎失效</li>
</ul>
<h3><a class="header" href="#开放定址" id="开放定址">开放定址</a></h3>
<h1><a class="header" href="#排序" id="排序">排序</a></h1>
<p>排序是指：给定 n 个整数，将它们按（非降）序排列。</p>
<p>排序算法大致可分为两类：</p>
<ul>
<li><strong>基于比较的排序</strong>（comparison based algorithm，C.B.A.）：归并排序、冒泡排序、快速排序、希尔排序，其时间复杂度的下限为 \(O(nlogn)\)</li>
<li><strong>非基于比较的排序</strong>：桶排序、计数排序、基数排序</li>
</ul>
<p>排序算法的<strong>稳定性</strong>（stability）指重复元素在输入、输出序列中的相对次序，是否保持不变？</p>
<ul>
<li><strong>稳定的排序</strong>：归并排序、插入排序、冒泡排序</li>
<li><strong>不稳定的排序</strong>：快速排序、堆排序</li>
</ul>
<p>输入含重复元素时，算法的稳定性是更为细致的要求。</p>
<p>排序算法多种多样，对于程序员来说，重点需要熟记<strong>归并排序</strong>、<strong>快速排序</strong>、<strong>堆排序</strong>和<strong>插入排序</strong>这四种。</p>
<p>各个排序的时间复杂度如下：</p>
<table><thead><tr><th>排序</th><th>最坏时间复杂度</th><th>平均时间复杂度</th><th>空间复杂度</th></tr></thead><tbody>
<tr><td>归并排序</td><td>\(O(nlogn)\)</td><td>\(O(nlogn)\)</td><td>无</td></tr>
<tr><td>快速排序</td><td>\(O(n^2)\)</td><td>\(O(nlogn)\)</td><td>\(O(1)\)</td></tr>
<tr><td>堆排序</td><td>\(O(nlogn)\)</td><td>\(O(nlogn)\)</td><td>无</td></tr>
<tr><td>插入排序</td><td>\(O(n^2)\)</td><td>\(O(n^2)\)</td><td>无</td></tr>
<tr><td>冒泡排序</td><td>\(O(n^2)\)</td><td>\(O(n^2)\)</td><td>无</td></tr>
<tr><td>选择排序</td><td>\(O(n^2)\)</td><td>\(O(n^2)\)</td><td>无</td></tr>
<tr><td>计数排序</td><td>无</td><td>无</td><td>无</td></tr>
<tr><td>桶排序</td><td>无</td><td>无</td><td>无</td></tr>
<tr><td>希尔排序</td><td>无</td><td>无</td><td>无</td></tr>
</tbody></table>
<h1><a class="header" href="#归并排序" id="归并排序">归并排序</a></h1>
<p><strong>归并排序</strong>（merge sort）是<strong>分治策略</strong>的一种实现，具体来说，它将序列一分为二，分别的对子序列递归排序，最后合并有序子序列。</p>
<p>归并排序的核心是合并（merge）操作，即<strong>二路归并</strong>（2-way merge），指将两个有序序列合并为一个有序序列：<code>S[lo, hi) = S[lo, mi) + S[mi, hi)</code>。</p>
<p>合并时只需比较两个有序序列的第一个元素的大小即可。</p>
<pre><code class="language-python">def merge(left, right):
    result = []
    while left and right:
        if left[0] &lt;= right[0]:
            result.append(left.pop(0))
        else:
            result.append(right.pop(0))
    if left:
        result += left
    if right:
        result += right
    return result


def mergesort(lis):  # [lo, hi)
    if len(lis) &lt; 2:  # 单元素区间自然有序，否则...
        return lis
    mi = len(lis) &gt;&gt; 1  # 以中点为界
    left = mergesort(lis[:mi])  # 对前半段排序
    right = mergesort(lis[mi:])  # 对后半段排序
    return merge(left, right)  # 归并


# 测试
lis = [4, 3, 8, 7, 1, 9, 6]
print(mergesort(lis))  # [1, 3, 4, 6, 7, 8, 9]
</code></pre>
<p>归并排序的最坏时间复杂度为 \(O(nlogn)\)。</p>
<p>LeetCode：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></p>
<h1><a class="header" href="#快速排序" id="快速排序">快速排序</a></h1>
<p><strong>快速排序</strong>（quick sort）同样是分治策略的一种体现，它的思想为将序列分为两个子序列，且前一个子序列的数都不大于后一个子序列，在子序列分别递归地排序之后，原序列自然有序。</p>
<p>由此可见，归并排序的计算量和难点在于<strong>合</strong>，而快速排序在于<strong>分</strong>。</p>
<p>要实现以上所述的那种子序列的划分，其关键在于寻找<strong>轴点</strong>（pivot），轴点左侧的元素均不比它更大，轴点右侧的元素均不比它更小。</p>
<p>显然，轴点必定已然就位。但坏消息是，在原始序列中，轴点未必存在。比如，在乱排（derangement）序列中，轴点就不存在。特别地，在有序序列中，所有元素皆为轴点，反之亦然。从这个角度来看，所谓的快速排序无非就是将所有元素逐个转换为轴点的过程。具体来说，通过适当交换，可使任一元素转换为轴点。</p>
<p>任何一个有序序列只要经过一次循环移位就可得到一个乱排序列，比如 <code>[2, 3, 4, ..., n, 1]</code>。</p>
<pre><code class="language-python">def partition(lis):
    pivot = lis[0]
    mi = 0
    for k in range(1, len(lis)+1):
        if lis[k] &lt; pivot:
            mi += 1
            lis[mi], lis[k] = lis[k], lis[mi]
    lis[0], lis[mi] = lis[mi], lis[0]
    return mi


def quicksort(lis):
    if len(lis) &lt; 2:  # 单元素区间自然有序，否则...
        return lis
    mi = partition(lis)  # 先构造轴点，再
    quicksort(lis[:mi])  # 对前半段排序
    quicksort(lis[mi:])  # 对后半段排序


# 测试
lis = [4, 3, 8, 7, 1, 9, 6]
print(quicksort(lis))  # [1, 3, 4, 6, 7, 8, 9]
</code></pre>
<p>快速排序是不稳定（unstable）的，<code>lo</code>/<code>hi</code> 的移动方向相反，左/右侧的大/小重复元素可能前/后颠倒。</p>
<p>快速排序是就地（in-place）的，只需 \(O(1)\) 的附加空间。</p>
<p>最好情况下，每次划分都（接近）平均，轴点总是（接近）中央，此时时间复杂度为 \(O(nlogn)\)。</p>
<p>最坏情况下，每次划分都极不均衡，比如，轴点总是最小或最大元素，此时时间复杂度为 \(O(n^2)\)，与冒泡排序相当！即便采用随机选取、（Unix）三者取中之类的策略，也只能降低最坏情况的概率，而无法杜绝。</p>
<p>随机选取：不再是每次都固定的将首元素作为候选轴点，而是在整个序列中，随机的选择其一。</p>
<p>三者取中：每次都是在整个序列中，随机的抽取三个元素，然后将其中数值居中的那个作为候选轴点。</p>
<p>以均匀独立分布为例，在平均情况下，其时间复杂度为 \(O(nlogn)\)，特别的，\(n\) 约等于 1.39。</p>
<h1><a class="header" href="#堆排序" id="堆排序">堆排序</a></h1>
<pre><code class="language-python">from heapq import heappush, heappop


def heapsort(iterable):
    h = []
    for value in iterable:
        heappush(h, value)
    return [heappop(h) for i in range(len(h))]


lis = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]
print(heapsort(lis))
</code></pre>
<h1><a class="header" href="#插入排序" id="插入排序">插入排序</a></h1>
<h1><a class="header" href="#冒泡排序" id="冒泡排序">冒泡排序</a></h1>
<p>冒泡排序（bubble sort）又称起泡排序。它主要基于以下观察：</p>
<ul>
<li><strong>有序</strong>序列中，<strong>任意</strong>一对相邻元素<strong>顺序</strong></li>
<li><strong>无序</strong>序列中，<strong>总有</strong>一对相邻元素<strong>逆序</strong></li>
</ul>
<p>为此，要执行<strong>扫描交换</strong>，即依次比较每一对相邻元素，如有必要，交换之；若整趟扫描都没有进行交换，则排序完成；否则，再做一趟扫描交换。</p>
<p>Python 实现：</p>
<pre><code class="language-python"></code></pre>
<p>C 实现：</p>
<pre><code class="language-c">void bubblesort(int A[], int n)
{
    for(bool sorted = false; sorted = !sorted; n--)  // 逐趟扫描交换，直至完全有序
    {
        for(int i = 1; i &lt; n; i++)  // 自左向右，逐对检查A[0, n)内各相邻元素
        {
            if(A[i-1] &gt; A[i])  // 若逆序，则
            {
                swap(A[i-1], A[i]);  // 令其互换，同时
                sorted = false;  // 清除（全局）有序标志
            }
        }
    }
}
</code></pre>
<p>冒泡排序是稳定的排序，这是因为，在冒泡排序中，元素 a 和 b 的相对位置发生变化，只有一种可能：经分别与其他元素的交换，二者相互接近直至相邻，在接下来一轮扫描交换中，二者因逆序而交换位置。</p>
<h1><a class="header" href="#选择排序" id="选择排序">选择排序</a></h1>
<h1><a class="header" href="#计数排序" id="计数排序">计数排序</a></h1>
<pre><code class="language-python">def countingsort(lis):
    length = max(lis)-min(lis)+1
    count = [0]*length
    for i in lis:
        count[i] += 1
    for index in range(0, len(count)):
        count[index] += count[index-1]
    return count


lis = [6, 3, 8, 4, 2, 6, 3, 7, 3]
sorted_list = countingsort(lis)
print(sorted_list)
</code></pre>
<p>LeetCode：<a href="https://leetcode-cn.com/problems/relative-sort-array/">1122. 数组的相对排序</a></p>
<h1><a class="header" href="#桶排序" id="桶排序">桶排序</a></h1>
<p>LeetCode：<a href="https://leetcode-cn.com/problems/maximum-gap/">164. 最大间距</a></p>
<h1><a class="header" href="#希尔排序" id="希尔排序">希尔排序</a></h1>
<h1><a class="header" href="#查找-3" id="查找-3">查找</a></h1>
<h1><a class="header" href="#二分查找" id="二分查找">二分查找</a></h1>
<p>二分查找是减治策略的一种体现。</p>
<p>以任一元素 <code>x = S[mi]</code> 为界，都可将待查找区间分为 2 部分，即 <code>S[lo, mi) &lt;= S[mi, hi)</code>，其中 <code>S[mi]</code> 称作轴点，只需将目标元素 <code>e</code> 与 <code>x</code> 做一比较，即可分 2 种情况进一步处理：</p>
<ol>
<li><code>e &lt; x</code>：则 e 若存在必属于<strong>左</strong>侧子区间 <code>S[lo, mi)</code>，故可递归深入</li>
<li><code>x &lt;= e</code>：则 e 若存在必属于<strong>右</strong>侧子区间 <code>S[mi, hi)</code>，亦可递归深入</li>
</ol>
<p>二分（折半）策略：轴点 mi 总是取作中点，则查找每深入一层，问题规模也缩减<strong>一半</strong>。</p>
<p>此外，为了语义约定，查找的返回值为不大于 e 的最后一个元素。</p>
<pre><code class="language-python">def bin_search(A, e, lo, hi):  # 在有序向量区间[lo, hi)内查找元素e
    while lo &lt; hi:  # 不变性：A[0, lo) &lt;= e &lt; A[hi, n)
        mi = (lo+hi) &gt;&gt; 1  # 以中点为轴点，经比较后确定深入
        if e &lt; A[mi]:
            hi = mi  # 深入前半段[lo, mi)继续查找
        else:
            lo = mi + 1  # 深入后半段(mi, hi)
    return lo-1  # 出口时，A[lo=hi]为大于e的最小元素，故lo-1即不大于e的元素的最大秩


# 测试
lis = [2, 5, 6, 9, 10, 12, 13]
print(bin_search(lis, 12, 0, len(lis)))  # 5
print(bin_search(lis, 11, 0, len(lis)))  # 4
</code></pre>
<p>其平均时间复杂度约为 \(O(1.5\times logn)\)。</p>
<p>LeetCode：<a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a></p>
<h1><a class="header" href="#fibonacci-查找" id="fibonacci-查找">Fibonacci 查找</a></h1>
<p>二分查找和 Fibonacci 查找都有一个通用策略，即对于任何的 A[0, n)，总是选取 \(A[\lambda n]\) 作为轴点，其中 \(0\leq\lambda&lt;1\)。</p>
<p>具体来说，二分查找对应于 \(\lambda=0.5\)，Fibonacci 查找对应于 \(\lambda=\phi=0.6180339...\)。</p>
<p>比如，若设 <code>n=fib(k)-1</code>，则可取 <code>mi=fib(k-1)-1</code>，于是，前、后子向量的长度分别为 <code>fib(k-1)-1</code>、<code>fib(k-2)-1</code>。</p>
<pre><code class="language-python">def fib_search(A, e, lo, hi):
    Fib fib(hi-lo)
    while lo &lt; hi:
        while hi-lo&lt;fib.get():
            fib.prev()
        mi = lo + fib.get() - 1  # 按黄金比例切分
        if e &lt; A[mi]:
            hi = mi  # 深入前半段[lo, mi)继续查找
        elif A[mi] &lt; e:
            lo = mi + 1  # 深入后半段(mi, hi)
        else:
            return mi  # 在mi处命中
    return -1
</code></pre>
<p>其平均时间复杂度约为 \(O(1.44\times logn)\)。</p>
<h1><a class="header" href="#插值查找" id="插值查找">插值查找</a></h1>
<p>假设已知有序向量中各元素随机分布的规律，比如均匀且独立的随机分布，于是 <code>[lo, hi)</code> 内各元素应大致按照线性趋势增长，即 \(\frac{mi-lo}{hi-lo}\approx\frac{e-A[lo]}{A[hi]-A[lo]}\)，因此，通过猜测轴点 <code>mi</code>，可以极大地提高收敛速度，即 \(mi\approx lo+(hi-lo)\times\frac{e-A[lo]}{A[hi]-A[lo]}\)。</p>
<p>例如，在英文词典中，<code>binary</code> 大致位于 \(\frac{2}{26}\) 处，<code>search</code> 大致位于 \(\frac{19}{26}\) 处。</p>
<p>按照姚期智先生早期的证明，在插值查找算法中，每经过一次比较，查找规模 n 缩至 \(\sqrt{n}\)。</p>
<p>通过以上定理可以计算得出其平均时间复杂度约为 \(O(loglogn)\)。</p>
<p>在实际中，插值算法通常优势不明显 —— 除非查找区间宽度极大，或者比较操作成本极高；此外，其易受小扰动的干扰和“蒙骗”；在具体实现时须引入乘法、除法运算，这也造成其实现成本较高。</p>
<p>所以，实际可行的方法是：首先通过插值查找，将查找范围缩小到一定的范围，然后再进行二分查找。</p>
<h1><a class="header" href="#字符串匹配" id="字符串匹配">字符串匹配</a></h1>
<p>字符串的具体实现并不难，借助之前的线性表数据结构即可轻松实现，在本节我们重点讨论字符串的相关算法。</p>
<h2><a class="header" href="#概念-1" id="概念-1">概念</a></h2>
<p><strong>字符串</strong>简称为 <strong>串</strong>，是指由 <strong>字母表 \(\sum\)</strong> 的字符所组成的 <strong>有限序列</strong>，即 \(S=a_0a_1a_2...a_{n-1} \in \sum^*\)。</p>
<p>字符串与常规的线性表又有些许不同，通常，字符的种类不多，而\(串长=n \gg |\sum|\)。</p>
<p>一般地，如果一个名为 <code>S</code> 的字符串由 <code>n</code> 个字符构成，我们就将所有的字符从前至后编号为 <code>0</code> 至 <code>n-1</code>，并按照我们的惯例，记作 <code>S[0, n)</code>，而串中秩为 <code>k</code> 的字符，也相应地记作 <code>S[k]</code>。</p>
<p>两个字符串<strong>相等</strong>是指 <code>S[0, n) = T[0, m)</code>，即长度相等（<code>n = m</code>），且对应的字符均相同（<code>S[i] = T[i]</code>）。</p>
<p>对于任何一个字符串 <code>S</code> 而言，由 <code>i</code> 和 <code>k</code> 所指定的那个<strong>子串</strong>，也就是从秩为 <code>i</code> 的那个字符开始，<strong>连续</strong>的 <code>k</code> 个字符。</p>
<p>所谓的<strong>前缀</strong>（prefix）是子串的一个特例，具体来说，所谓长度为 <code>k</code> 的前缀，也就是起始于首字符的前 <code>k</code> 个字符。</p>
<p>对称的，所谓长度为 <code>k</code> 的<strong>后缀</strong>（suffix），也就是终止于末元素的最靠后的 <code>k</code> 个字符。</p>
<p>不难验证，所谓起始于 <code>i</code>，长度为 <code>k</code> 的子串，也就是在长度为 <code>i+k</code> 的前缀中，长度为 <code>k</code> 的后缀。</p>
<p>对于串长 <code>n</code> 为 <code>0</code> 的串称之为<strong>空串</strong>，空串与由空格组成的串并不是一回事，空串是任何串的子串、前缀、后缀。</p>
<p>此外，任何串也是其自身的子串、前缀、后缀。反过来，长度严格小于原串的子串、前缀、后缀也称作<strong>真子串</strong>、<strong>真前缀</strong>、<strong>真后缀</strong>。</p>
<p>注意，从上面可以看出子串和子序列不是一回事，子串是连续的，子序列则未必连续。</p>
<h2><a class="header" href="#串匹配" id="串匹配">串匹配</a></h2>
<p>字符串匹配具体指在<strong>文本串 T</strong> 中找到<strong>模式串 P</strong> 的过程。记 \(n=|T|\) 和 \(m=|P|\)，通常有 \(n\gg m\gg 2\)。</p>
<p>字符串匹配又称<strong>模式匹配</strong>（pattern matching），其可以分为 4 个层次：</p>
<ol>
<li>detection：P <em>是否</em> 出现？</li>
<li>location：首次 <em>在哪里</em> 出现？</li>
<li>counting：共有 <em>几次</em> 出现？</li>
<li>enumeration：各出现 <em>在哪里</em>？</li>
</ol>
<p>我们本节重点讨论第 2 个层次。</p>
<h1><a class="header" href="#暴力匹配" id="暴力匹配">暴力匹配</a></h1>
<p><strong>暴力匹配</strong>（Brute Force，<strong>BF</strong>）又称为蛮力匹配或朴素匹配算法，自左向右，以字符为单位，依次移动模式串，直到在某个位置，发现匹配。</p>
<pre><code class="language-python">def match(P, T):
    n = len(T)  # T[i]与P[0]对齐
    m = len(P)  # T[i+j]与P[j]对齐
    for i in range(n-m+1):  # T从第i个字符起，与
        for j in range(m):  # P中对应的字符逐个比对
            if T[i+j] != P[j]:  # 若失配，P整体右移一个字符，重新比对
                break
        if j == m-1:  # 找到匹配子串
            break
    return i


# 测试
P = '1011'
T = '1001101101'
print(match(P, T))
</code></pre>
<p>暴力匹配的最坏时间复杂度为 \(O(n\times m)\)，\(|\sum|\) 越小，最坏情况出现的概率越高，\(m\) 越大，最坏情况的后果更加严重。</p>
<h1><a class="header" href="#kmp" id="kmp">KMP</a></h1>
<p><strong>KMP</strong>（D.E.<strong>K</strong>nuth, J.H.<strong>M</strong>orris, V.R.<strong>P</strong>ratt）算法可以看作是对暴力匹配的一种改进，具体来说，在每一次失败之后，应该将模式串中的某一个字符与文本串中刚才失败的那个字符彼此重新对齐。</p>
<p>比如：</p>
<pre><code class="language-python">T = 'ZHREGRETBA'
P =   'REGROW'
P =      'REGROW'
</code></pre>
<p>当 <code>T</code> 中的 <code>E</code> 与 <code>P</code> 中的 <code>O</code> 失配后，我们应将 <code>P</code> 中的 <code>E</code> 重新与 <code>T</code> 中的 <code>E</code> 进行比较，此时 <code>P</code> 向后移动了 3 位。</p>
<p>如何确定模式串中要进行对齐的那个继任字符呢？我们需要借助 <code>next</code> 查询表，由此可见 KMP 算法的核心在于构造 <code>next</code> 查询表。</p>
<p>构造查询表 <code>next[0, m)</code>：在任一位置 <code>P[j]</code> 处失败之后，将 <code>j</code> 替换为 <code>next[j]</code>。</p>
<p>所谓 <code>next[j]</code>，即是在 <code>P[0, j)</code> 中，最大自匹配的真前缀和真后缀的长度。</p>
<p>比如，<code>P = 'chinchilla'</code>：</p>
<ul>
<li><code>next[0]</code>，即 <code>P[0, 0) == ''</code>：设为 -1</li>
<li><code>next[1]</code>，即 <code>P[0, 1) == 'c'</code>：真前缀为空串，真后缀也为空串，最大自匹配长度为 0</li>
<li><code>next[2]</code>，即 <code>P[0, 2) == 'ch'</code>：真前缀只有 <code>'c'</code>，真后缀只有 <code>'h'</code>，最大自匹配长度为 0</li>
<li><code>next[3]</code>，即 <code>P[0, 3) == 'chi'</code>：真前缀有 <code>['c', 'ch']</code>，真后缀有 <code>['i', 'hi']</code>，最大自匹配长度为 0</li>
<li><code>next[4]</code>，即 <code>P[0, 4) == 'chin'</code>：真前缀有 <code>['c', 'ch', 'chi']</code>，真后缀有 <code>['n', 'in', 'hin']</code>，最大自匹配长度为 0</li>
<li><code>next[5]</code>，即 <code>P[0, 5) == 'chinc'</code>：真前缀有 <code>['c', 'ch', 'chi', 'chin']</code>，真后缀有 <code>['c', 'nc', 'inc', 'hinc']</code>，最大自匹配为 <code>'c'</code>，长度为 1</li>
<li><code>next[6]</code>，即 <code>P[0, 6) == 'chinch'</code>：真前缀有 <code>['c', 'ch', 'chi', 'chin', 'chinc']</code>，真后缀有 <code>['h', 'ch', 'nch', 'inch', 'hinch']</code>，最大自匹配为 <code>'ch'</code>，长度为 2</li>
<li><code>next[7]</code>，即 <code>P[0, 7) == 'chinchi'</code>：真前缀有 <code>['c', 'ch', 'chi', 'chin', 'chinc', 'chinch']</code>，真后缀有 <code>['i', 'hi', 'chi', 'nchi', 'inchi', 'hinchi']</code>，最大自匹配为 <code>'chi'</code>，长度为 3</li>
<li><code>next[8]</code>，即 <code>P[0, 8) == 'chinchil'</code>：真前缀有 <code>['c', 'ch', 'chi', 'chin', 'chinc', 'chinch', 'chinchi']</code>，真后缀有 <code>['l', 'il', 'hil', 'chil', 'nchil', 'inchil', 'hinchil']</code>，最大自匹配长度为 0</li>
<li><code>next[9]</code>，即 <code>P[0, 9) == 'chinchill'</code>：真前缀有 <code>['c', 'ch', 'chi', 'chin', 'chinc', 'chinch', 'chinchi', 'chinchil']</code>，真后缀有 <code>['l', 'll', 'ill', 'hill', 'chill', 'nchill', 'inchill', 'hinchill']</code>，最大自匹配长度为 0</li>
</ul>
<p>则其 <code>next</code> 表为 <code>[-1, 0, 0, 0, 0, 1, 2, 3, 0, 0]</code>。</p>
<p>KMP 算法实现如下：</p>
<pre><code class="language-python">def build_next(P):  # 构造模式串P的next[]表
    m = len(P)
    j = 0  # “主”串指针
    N = [-1]  # next[]表
    t = N[0]  # 模式串指针（P[-1]通配符）
    while j &lt; m-1:
        if t &lt; 0 or P[j] == P[t]:  # 匹配
            j += 1
            N.append(t+1)
        else:  # 失配
            t = N[t]
    return N


def match(P, T):
    next = build_next(P)  # 构造next表
    n = len(T)
    i = 0  # 文本串指针
    m = len(P)
    j = 0  # 模式串指针
    while j &lt; m and i &lt; n:  # 自左向右，逐个比对字符
        if j &lt; 0 or T[i] == P[j]:  # 若匹配
            i += 1  # 则携手共进
            j += 1
        else:  # 否则，P右移，T不回退
            j = next[j]
    del next  # 释放next表
    return i-j


# 测试
T = '1001101101'
P = '1011'
print(match(P, T))  # 4
</code></pre>
<p>在最坏情况下，其时间复杂度为 \(O(n)\)，具体来说，对于长度为 \(n\) 的文本串和长度为 \(m\) 的模式串，其时间复杂度为 \(O(n+m)\)</p>
<h2><a class="header" href="#参考" id="参考">参考</a></h2>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">字符串匹配的KMP算法</a></li>
<li><a href="https://dsa.cs.tsinghua.edu.cn/%7Edeng/ds/src_link/string_pm_kmp/pm_kmp.cpp.htm">pm_kmp.cpp</a></li>
<li><a href="https://dsa.cs.tsinghua.edu.cn/%7Edeng/ds/src_link/string_pm_kmp/pm_kmp_next.cpp.htm">pm_kmp_next.cpp</a></li>
<li><a href="https://dsa.cs.tsinghua.edu.cn/%7Edeng/ds/src_link/string_pm_kmp_improved/pm_kmp_next_improved.cpp.htm">pm_kmp_next_improved.cpp</a></li>
<li><a href="https://dsa.cs.tsinghua.edu.cn/%7Edeng/ds/src_link/_java/dsa/pm_kmp.java.htm">pm_kmp.java</a></li>
</ul>
<h1><a class="header" href="#bm" id="bm">BM</a></h1>
<h2><a class="header" href="#参考-1" id="参考-1">参考</a></h2>
<ul>
<li><a href="https://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html">字符串匹配的Boyer-Moore算法</a></li>
</ul>
<h1><a class="header" href="#rabinkarp" id="rabinkarp">Rabin–Karp</a></h1>
<p>Rabin–Karp 又称 Karp-Rabin</p>
<h1><a class="header" href="#策略" id="策略">策略</a></h1>
<h1><a class="header" href="#贪心" id="贪心">贪心</a></h1>
<h1><a class="header" href="#减治" id="减治">减治</a></h1>
<p><strong>减治</strong>（Decrease-and-conquer）又称减而治之，为求解一个大规模的问题，可以将其划分为两个子问题：其一平凡，另一规模缩减，分别求解子问题，由子问题的解，得到原问题的解。</p>
<p>典型的算法有二分查找等。</p>
<h1><a class="header" href="#分治" id="分治">分治</a></h1>
<p><strong>分治</strong>（Divide-and-conquer）又称分而治之，为求解一个大规模的问题，可以将其划分为若干（通常两个）子问题，规模大体相当，分别求解子问题，由子问题的解，得到原问题的解。</p>
<p>典型算法有归并排序、快速排序等。</p>
<h1><a class="header" href="#动态规划" id="动态规划">动态规划</a></h1>
<p>动态规划实际上是把原来递归的过程倒过来实现。</p>
<pre><code class="language-python">def fib(n):
    if n &lt; 2:
        return n
    else:
        return fib(n-1) + fib(n-2)


# Memoization 记忆化
def fib_a(n):
    M = []
    if n &lt; 2:
        return n
    else:
        if not M[n]:
            M[n] = fib(n-1) + fib(n-2)
    return M[n]
</code></pre>
<h1><a class="header" href="#滑动窗口" id="滑动窗口">滑动窗口</a></h1>
<p>滑动窗口一般用于解决从数组或字符串中找出<strong>连续</strong>的子数组或子串的问题。</p>
<p>给定一个数组，找出数组中连续 3 个数的最大值。如 <code>[1, 4, 2, 6, 4, 5, 3]</code> 中最大值是 15，即 <code>[6, 4, 5]</code>。</p>
<pre><code class="language-python">nums = [1, 4, 2, 6, 4, 5, 3]


def brute(nums):
    max_value = 0
    for i in nums:
        max_value = max(max_value, sum(nums[i:i+3]))
    return max_value


def sliding_window(nums):
    start = 1
    end = 3
    max_value = sum(nums[0:2])
    while end &lt; len(nums):
        max_value = max(max_value, max_value-nums[start-1]+nums[end])
        end += 1
        start += 1
    return max_value


brute(nums)
sliding_window(nums)
</code></pre>
<p>LeetCode：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></li>
<li><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></li>
<li><a href="https://leetcode-cn.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/">1456. 定长子串中元音的最大数目</a></li>
</ul>
<h1><a class="header" href="#常用算法" id="常用算法">常用算法</a></h1>
<h1><a class="header" href="#lru" id="lru">LRU</a></h1>
<pre><code class="language-python">from collections import OrderedDict


class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity  # cache的容量
        self.visited = OrderedDict()  # python内置的OrderDict具备排序的功能

    def get(self, key: int) -&gt; int:
        if key not in self.visited:
            return -1
        self.visited.move_to_end(key)  # 最近访问的放到链表最后，维护好顺序
        return self.visited[key]

    def put(self, key: int, value: int) -&gt; None:
        if key not in self.visited and len(self.visited) == self.capacity:
            # last=False时，按照FIFO顺序弹出键值对
            # 因为我们将最近访问的放到最后，所以最远访问的就是最前的，也就是最first的，故要用FIFO顺序
            self.visited.popitem(last=False)
        self.visited[key] = value
        self.visited.move_to_end(key)    # 最近访问的放到链表最后，维护好顺序
</code></pre>
<p>LeetCode：<a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制</a></p>
<h1><a class="header" href="#并查集" id="并查集">并查集</a></h1>
<p>LeetCode：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></li>
<li><a href="https://leetcode-cn.com/problems/number-of-provinces/">547. 省份数量</a></li>
</ul>
<h1><a class="header" href="#常考题型" id="常考题型">常考题型</a></h1>
<h1><a class="header" href="#刷题总结" id="刷题总结">刷题总结</a></h1>
<h2><a class="header" href="#套路" id="套路">套路</a></h2>
<p>题目中有 <em>最大</em> 或 <em>最小</em> 的，一般都可以先通过排序再解决。</p>
<h2><a class="header" href="#python" id="python">Python</a></h2>
<p><code>max</code> 函数获取一个列表的最大值：</p>
<pre><code class="language-python">a = [1, 0, 3]
print(max(a))  # 3
</code></pre>
<p><code>bin</code> 函数用于生成一个数值的二进制形式：</p>
<pre><code class="language-python">a = 55
bin(a)  # '0b110111'
</code></pre>
<p>统计序列中某元素出现的次数：</p>
<pre><code class="language-python">a = [1, 0, 0]
a.count(0)  # 2
</code></pre>
<p>集合的交集、并集、差集：</p>
<pre><code class="language-python">a = {1, 2, 3}
b = {1, 2, 3, 4, 5}
a &amp; b  # 交集，输出 {1, 2, 3}
a | b  # 并集，输出 {1, 2, 3, 4, 5}
b - a  # 差集，输出 {4, 5}
</code></pre>
<p><code>collections</code> 模块里的 <code>Counter</code> 对象可以很方便的统计元素出现的次数，如下：</p>
<pre><code class="language-python">from collections import Counter
dict(Counter('gallahad'))  # {'g': 1, 'a': 3, 'l': 2, 'h': 1, 'd': 1}
dict(Counter('gallahad').most_common())  # {'a': 3, 'l': 2, 'g': 1, 'h': 1, 'd': 1}
</code></pre>
<p><code>itertools</code> 模块里提供有排列组合的相关函数，如下：</p>
<pre><code class="language-python">from itertools import permutations, combinations
nums = [1, 2, 3]
# 排列，输出 [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]
list(permutations(nums, 3))
# 组合，输出 [(1, 2), (1, 3), (2, 3)]
list(combinations(nums, 2))
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
