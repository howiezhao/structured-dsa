# 优先级队列

**优先级队列**即通过优先级访问的队列，这种方式可称为循优先级访问（call-by-priority）。

为了高效的实现优先级队列这种数据结构，我们可以使用完全二叉堆实现它。

**完全二叉树**（Complete Binary Tree）是指平衡因子处处非负（即为 0 或 +1）的 AVL 树。对树中的任何一个节点 v 而言，若它的平衡因子为 0，那么它的左子树必然是满树；若它的平衡因子为 +1，那么它的右子树必然是满树。就全局的拓扑连接而言，如果忽略完全二叉树的最底层，那么其余节点应该组成一棵满树，而最底层也只不过是缺失了右侧的连续一段。

我们可以将优先级队列在逻辑上等同于完全二叉树，而在物理上可以直接借助顺序表实现。

逻辑节点与物理元素之间，依层次遍历次序彼此对应。具体来说，对于顺序表中秩为 \\(i\\) 的元素，它的父节点若存在，则是秩为 \\((i-1)\div 2\\) 的元素；它的左孩子若存在，则是秩为 \\(i\times 2+1\\)（奇数）的元素；它的右孩子若存在，则是秩为 \\((i+1)\times 2\\)（偶数）的元素。

这种实现优先级队列的方法借助了完全二叉树，因此也被称为**完全二叉堆**（Complete Binary Heap）。

完全二叉堆除了上述特点外，还应该有**堆序性**，即需要在完全二叉堆的所有节点之间定义某种次序。简而言之，任何一个节点在数值上都不会超过它的父亲。故根节点即是全局最大元素。

## 增加

为插入词条 e，只需将 e 作为末元素接入向量。至此，结构性自然保持，若堆序性也亦未破坏，则完成。否则，只能是 e 与其父节点违反堆序性，此时可将 e 与其父节点换位。若堆序性因此恢复，则完成。否则，依然只可能是 e 与其（新的）父节点违反堆序性，此时可再将 e 与其（新的）父节点换位。不断重复，直到 e 与其父亲满足堆序性，或者 e 到达堆顶（没有父亲）。这一过程，亦即所谓的**上滤**（percolate up）。

## 删除

这一过程，亦即所谓的**下滤**（percolate down）。

## 建堆

### 自上而下的上滤

### 自下而上的下滤
