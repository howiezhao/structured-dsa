# Introduction

所谓**算法**，即特定**计算模型**下，旨在解决特定问题的指令序列。具体来说，其包含以下要素：

- **输入**：待处理的信息（问题）
- **输出**：经处理的信息（答案）
- **正确性**：的确可以解决指定的问题
- **确定性**：任一算法都可以描述为一个由基本操作组成的序列
- **可行性**：每一基本操作都可实现，且在常数时间内完成
- **有穷性**：对于任何输入，经有穷次基本操作，都可以得到输出

一个好的算法包含以下特性：

- **正确**：符合语法，能够编译、链接
- **健壮**：能辨别不合法的输入并做适当处理，而不致非正常退出
- **可读**：结构化 + 准确命名 + 注释 + ...
- **效率**：速度尽可能快；存储空间尽可能少

在本系列文章中，我们重点关注效率方面。

算法分析主要包括两个方面：

- **正确性**：算法功能与问题要求一致？
- **成本**：运行时间 + 所需存储空间

通过挖掘算法的**不变性**和**单调性**可以证明算法的正确性。

## 大 O 记号

**大 O 记号**（big-O notation）：\\(T(n) = O(f(n))\\) iff \\(\exists c > 0\\)，当 \\(n >> 2\\) 后，有 \\(T(n) < c \times f(n)\\)

根据以上定义，我们可以得出关于大 O 记号的两个重要处理手法：

- 常系数可忽略：\\(O(f(n)) = O(c \times f(n))\\)
- 低次项可忽略：\\(O(n^a + n^b) = O(n^a), a > b > 0\\)

除此之外，还有以下记号：

- \\(T(n) = \Omega(f(n))\\)：\\(\exists c > 0\\)，当 \\(n >> 2\\) 后，有 \\(T(n) > c \times f(n)\\)
- \\(T(n) = \Theta(f(n))\\)：\\(\exists c_1 > c_2 > 0\\)，当 \\(n >> 2\\) 后，有 \\(c_1 \times f(n) > T(n) > c_2 \times f(n)\\)

根据大 O 记号，我们可以把时间复杂度分为以下几类：

- \\(O(1)\\)：常数（constant function）复杂度，这类算法的效率最高，不含转向（循环、调用、递归等），必顺序执行，即是 \\(O(1)\\)
- \\(O(logn)\\)：对数复杂度，常底数无所谓，常数次幂也无所谓，这类算法非常有效，复杂度无限接近于常数。
- \\(O(n^c)\\)：多项式（polynomial function）复杂度，其中一个特例是线性（\\(O(n)\\)）复杂度，这类算法的效率通常认为已可令人满意。
- \\(O(2^n)\\)：指数（exponential function）复杂度，这类算法的计算成本增长极快，通常被认为不可忍受。

从 \\(O(n^c)\\) 到 \\(O(2^n)\\)，是从有效算法到无效算法的分水岭。很多问题的 \\(O(2^n)\\) 算法往往显而易见，然而，设计出 \\(O(n^c)\\) 算法却极其不易，甚至，有时注定地只能是徒劳无功。

## 级数

- **算数级数**：与**末项平方**同阶
- **幂方级数**：比幂次高出**一阶**
- **几何级数**（a>1）：与末项同阶
- **收敛级数**：\\(O(1)\\)
- **调和级数**：\\(\Theta(logn)\\)
- **对数级数**：\\(\Theta(nlogn)\\)

```c
// 算数级数，O(n^2)
for(int i = 0; i < n; i++)
{
    for(int j = 0; j < n; j++)
    {
        O1Operation(i, j);
    }
}
```

```c
// 算数级数，O(n^2)
for(int i = 0; i < n; i++)
{
    for(int j = 0; j < i; j++)
    {
        O1Operation(i, j);
    }
}
```

```c
// 算数级数，O(n^2)
for(int i = 0; i < n; i++)
{
    for(int j = 0; j < i; j += 2013)
    {
        O1Operation(i, j);
    }
}
```

```c
// 几何级数，O(n)
for(int i = 1; i < n; i <<= 1)
{
    for(int j = 0; j < i; j++)
    {
        O1Operation(i, j);
    }
}
```

```c
// 几何级数，O(logn*2^logn)
for(int i = 0; i <= n; i++)
{
    for(int j = 1; j < i; j += j)
    {
        O1Operation(i, j);
    }
}
```

## 封底估算

封底估算即 Back-Of-The-Envelope Calculation。

\\(1 天 = 24 hr \times 60 min \times 60 sec \approx 25 \times 4000 = 10^5 sec\\)

\\(1 生 \approx 1 世纪 = 100 yr \times 365 = 3 \times 10^4 day = 3 \times 10^9 sec\\)

----

数据结构通常可分为：

- 线性数据结构：线性表、栈、队列
- 非线性数据结构：树、图

也可以按照数据访问方式分为：

- 寻秩访问（call by rank）：顺序表
- 寻位置访问（call by position）：链表
- 寻关键码访问（call by key）：二叉搜索树
- 寻数值访问（call by value）：哈希
