# 树

前面已经介绍了顺序表和链表这两种线性数据结构，我们来对比一下在其上执行操作的时间复杂度：

操作 | 顺序表 | 链表
--- | --- | ---
静态操作：查找 | \\(O(logn)\\) | \\(O(n)\\)
动态操作：增加/删除 | \\(O(n)\\) | \\(O(1)\\)

树结构则是将顺序表和链表的优势结合起来，可以理解为链表的链表，也可以认为是二维的链表，由于这个原因，可以认为树型结构既不是我们此前所介绍的线性数据结构，同时它也带有一定的线性特征，为了与之后的非线性数据结构 —— 图相区别，我们不妨称其为**半线性数据结构**。

树是用来按照层次关系组织一系列数据项的一种方式。

树是特殊的图 T=(V, E)，节点数 |V|=n，边数 |E|=e。

指定任一节点 \\(r\in V\\) 作为根后，T 即称作**有根树**（rooted tree）。

若 \\(T_1,T_2,...T_d\\) 为有根树，则 \\(T=()\\) 也是。相对于 \\(T\\)，\\(T_i\\) 称作以 \\(r_i\\) 为根的**子树**（subtree rooted at \\(r_i\\)），记作 \\(T_i=subtree(r_i)\\)。\\(r_i\\) 称作 r 的**孩子**（child），\\(r_i\\) 之间互称**兄弟**（sibling）。r 为其**父亲**（parent），d=degree(r) 为 r 的（出）**度**（degree）。

可归纳证明：\\(e=n-1\\)

若指定 \\(T_i\\) 作为 T 的第 i 棵子树，\\(r_i\\) 作为 r 的第 i 个孩子，则 T 称作**有序树**（ordered tree）。

可以采用**长子兄弟**表示法表示一棵树。
