# 字典

字典即 dictionary，又称词典。

哈希即 hash，又称散列或紧凑。

桶（bucket）：直接存放或间接指向一个词条

哈希表（hash table）/散列表/桶数组（bucket array）

## 哈希函数

哈希函数又称散列函数。

最简单的哈希函数就是直接对哈希表的长度取模。

哈希冲突/散列冲突（hash collision），即存在 key1 != key2，但 hash(key1) = hash(key2)。冲突不可避免，适当的将哈希表的长度增长，可以减少冲突出现的概率。

一个好的哈希函数有以下特性：

- **确定**（determinism）：同一关键码总是被映射至同一地址
- **快速**（efficiency）：expected-O(1)
- **满射**（surjection）：尽可能充分地覆盖整个哈希空间
- **均匀**（uniformity）：关键码映射到哈希表各位置的概率尽量接近，可有效避免聚集（clustering）现象。

以下是一些常用的哈希函数：

- **除余法**：\\(hash(key) = key \bmod M\\)，M 为素数时，数据对哈希表的覆盖最充分，分布最均匀。
- **MAD 法**：MAD 即 multiply-add-divide，取 M 为素数，\\(a > 0\\)，\\(b > 0\\)，\\(a \bmod M \neq 0\\)，\\(hash(key) = (a \times key + b) \bmod M\\)
- **数字分析法**（selecting digits）：抽取 key 中的某几位，构成地址。
- **平方取中法**（mid-square）：取 \\(key^2\\) 的中间若干位，构成地址。
- **折叠法**（folding）：将 key 分割成等宽的若干段，取其总和作为地址。
- **位异或法 XOR**：将 key 分割成等宽的二进制段，经异或运算得到地址。

总之，哈希函数越是随机，越是没有规律，越好。

## 排解冲突

哈希表中的冲突无法避免，通过以下方法可以排解冲突：

### 多槽位

**多槽位**（multiple slots）：桶单元细分成若干槽位（slot），存放（与同一单元）冲突的词条。

只要槽位数目不多，依然可以保证 O(1) 的时间效率。

但是，需要为每个桶配备多少个槽，方能保证 O(1)？若预留过多，则空间浪费；无论预留多少，极端情况下仍有可能不够。

### 独立链

为了解决以上问题，可以采用独立链法。

**独立链**（linked-list chaining/separate chaining）：每个桶存放一个指针，冲突的词条，组织成链表。

它存在如下优点与缺点：

优点：

- 无需为每个桶预备多个槽位
- 任意多次的冲突都可解决
- 删除操作实现简单、统一

缺点：

- 指针需要额外空间
- 节点需要动态申请
- 空间未必连续分布，系统缓存几乎失效

### 开放定址
